package org.mnr.packages_java_lang_21;

import java.lang.reflect.Method;

public class ObjectClassMethods extends Object{
	private int id;
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}

	private String name;

	ObjectClassMethods(int id, String name){
		this.id=id;
		this.name=name;
	}
	public static void main(String[] args) {
		ObjectClassMethods obj	=	new ObjectClassMethods(1,"Naveen");
		
		ObjectClassMethods obj1	=	new ObjectClassMethods(1,"Naveen");
		
		ObjectClassMethods obj2	=	new ObjectClassMethods(2,"Naveen");
		
		ObjectClassMethods obj3 = null;
		
		System.out.println(obj.toString());
		System.out.println(obj.hashcode());
		System.out.println(obj1.hashcode());
		
		System.out.println(obj.equals(obj1));
		
		System.out.println(obj.equals(obj2));
		
		System.out.println(obj.equals(obj3));
		/*
		 * either == or equals methdo doesn't compare either object or content
		 * in StringBuffer class 
		 */
		
		System.out.println("***********************");
		StringBuffer sb	=	new StringBuffer("Naveen");
		StringBuffer sb1	=	new StringBuffer("Naveen");
		StringBuffer sb3	= sb1;
		System.out.println("sb hashcode:"+sb.hashCode());
		System.out.println("sb1 hashcode:"+sb1.hashCode());
		System.out.println(sb.equals(sb1));
		System.out.println(sb==sb1);
		System.out.println(sb1==(sb3));
		System.out.println("111111111111111");
		
		Thread thread	=	new Thread();
			System.out.println(thread==null);
			System.out.println(thread.equals(null));
				
		System.out.println("2222222222222222");
		
		String var="mnreddy";
		String var1="mnreddy";
		System.out.println(var.hashCode()==var1.hashCode());
		
		doubleEqualsOperator();
		
		getClassMethod();
			
		
	}
	
	public static void concept(){
		/*
		 * There are 12 methods in Object class
		 * Only 11 methods are available to its child class except
		 * private static native void registerNatives();
		 * Remaining methods are
		 * 1. toString()
		 * 2. hashcode()
		 * 3. equals()
		 * 4. clone()
		 * 5. finalize()
		 * 6. getClass()
		 * 7. wati()
		 * 8. wait(long ms)
		 * 9. wait(long ms, int ns)
		 * 10. notify()
		 * 11. notifyAll()
		 * 12. registerNatives()
		 */
	}
	
	public  String toString(){
		/*
		 * used for string representation of an object
		 * whenever we print an object, internally toString() method is called
		 * default implementation as follows
		 * return getClass().getName()+"@"+Integer.toHexString(hashCode());
		 */
		return getClass().getName()+"@"+Integer.toHexString(hashCode());
		/*
		 * For user defined pojos, we need to define our own implementation of toString
		 * as per the requirement for a meaningful representation. But for wrapper classes,
		 * there's already a meaningful toString() method built-in
		 *  
		 */
	}
	
	
	public int hashcode(){
		/*
		 * hashcode is unique code for each object generated by jvm based on its address
		 * Jvm uses this unique code while saving objects into hashing related data structures like hashtable or hashmap
		 * It can be overridden based on our requirement.
		 * It is highly recommaned to override this such way that each object will get a unique number
		 */
		return id;
		/*
		 * Here it will return id of each object, so it will be unique.
		 * hashcode() method is used by toString() method internally
		 */
	}

	 public boolean equals(Object obj) {
//	        return (this == obj);
		 /*
		  * this method can be used to compare only objects but not primitives
		  * if two objects are equal by this method then their hashcode must be same
		  * Even if two objects are not equal hashcode may be equal or unequal
		  * But if hashcodes of two objects are not equal then they can't be eqaul
		  * So there is a contract between hashcode method and equals method
		  * Hence one method is overriden other must be overridden
		  * if two objects are not equal by equals method then these objects are not equal
		  * by == operator
		  * If hashcode is different for two objects, then can't be equal by equals method
		  * 
		  * 
			 * Above is the default implementation compares the addresses of 
			 */
			
			/*
			 * while overriding equals method, we must take care of following 
			 * 1. meaning of equality
			 * 2. make sure to compare the objects of same type otherwise classcastexception
			 * 3. check if parmater is null otherwise chance of null pointer exception
			 */
		 try{
//			String name=this.name;
//			int id=	this.id;
			ObjectClassMethods object=(ObjectClassMethods)obj;//chance of clascastexception
			//if simplify the above exception, we can use instanceof operator 
			if(obj instanceof ObjectClassMethods){
			int id1=object.getId();
			String name2=object.getName();// chance of nullpointerexception
			if(name.equals(name2)&&id==id1)
				return true;
			}
			return false;
		 }catch(ClassCastException exception){
			 return false;
		 }
		 catch(NullPointerException exception){
			 return false;
		 }
	}
		
	 public static void doubleEqualsOperator(){
		 /*
		  * == is applicable on both objects and primitives
		  * while using between two operands, they must have some relationship i.e., p-c or c-p
		  * otherwise CE
		  * If two objects are equal by == operator then they are definately equal by equals method
		  * viceversa may or may not be true
		  * == operator can't be overriden but equals method can be
		  */
		 System.out.println("********doubleEqualOperator**********");
		 String name	=	"a";
		 String name1	=	"a";
		 System.out.println(name==name1);
		 System.out.println(name.hashCode()==name1.hashCode());
		 
		 
	 }
		
	 public static void getClassMethod(){
		 /*
		  * used to obtain the runtime definition of an object
		  * using this we can access all the class level properties 
		  * method informations and constructors
		  */
		  Object object	=	new String("Naveen");
		  
		  Class c1	=	object.getClass();
		  System.out.println("runtime class name::"+c1.getName());
		  Method[] methods= c1.getDeclaredMethods();	
		  for(Method m:methods){
			  System.out.println("method name:"+m.getName());
		  }
		 
	 }
	 @Override
	 public  void finalize(){
		 /*
		  * this method used for writing clean up code for objects.
		  * When gc is called, before destroying the object, this 
		  * method will be called
		  * 
		  */
		 System.out.println("finalize method called");
	 }
}
